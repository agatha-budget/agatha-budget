/* tslint:disable */
/* eslint-disable */
/**
 * Tresorier
 * Tr√©sorier api front to back
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, superTokenAxios as globalAxios} from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface Allocation
 */
export interface Allocation {
    /**
     * 
     * @type {number}
     * @memberof Allocation
     */
    'month': number;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    'categoryId': string;
    /**
     * 
     * @type {number}
     * @memberof Allocation
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface Budget
 */
export interface Budget {
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'profile': string;
    /**
     * 
     * @type {boolean}
     * @memberof Budget
     */
    'isDefault'?: boolean;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'masterCategoryId': string;
    /**
     * 
     * @type {boolean}
     * @memberof Category
     */
    'archived': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Category
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface CategoryData
 */
export interface CategoryData {
    /**
     * 
     * @type {number}
     * @memberof CategoryData
     */
    'allocated': number;
    /**
     * 
     * @type {number}
     * @memberof CategoryData
     */
    'spent': number;
    /**
     * 
     * @type {number}
     * @memberof CategoryData
     */
    'available': number;
}
/**
 * 
 * @export
 * @interface MasterCategory
 */
export interface MasterCategory {
    /**
     * 
     * @type {string}
     * @memberof MasterCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MasterCategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MasterCategory
     */
    'budgetId': string;
    /**
     * 
     * @type {boolean}
     * @memberof MasterCategory
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Operation
     */
    'day': number;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    'categoryId': string;
    /**
     * 
     * @type {number}
     * @memberof Operation
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    'memo': string;
}
/**
 * 
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof Person
     */
    'billingStatus': boolean;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'style': string;
    /**
     * 
     * @type {boolean}
     * @memberof Person
     */
    'dyslexia': boolean;
    /**
     * 
     * @type {number}
     * @memberof Person
     */
    'createDate'?: number;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new account
         * @param {string} budgetId 
         * @param {string} name 
         * @param {number} amount 
         * @param {number} day day as seen by user in his/her timezone, format : 2 january 2021 &#x3D;&gt; 20210102
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccount: async (budgetId: string, name: string, amount: number, day: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('addAccount', 'budgetId', budgetId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addAccount', 'name', name)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('addAccount', 'amount', amount)
            // verify required parameter 'day' is not null or undefined
            assertParamExists('addAccount', 'day', day)
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountId id of the account you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId)
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds accounts by budget
         * @param {string} budgetId id of the budget whose accounts you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountsByBudget: async (budgetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('findAccountsByBudget', 'budgetId', budgetId)
            const localVarPath = `/account/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rename an account
         * @param {string} accountId 
         * @param {string} newName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (accountId: string, newName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId)
            // verify required parameter 'newName' is not null or undefined
            assertParamExists('updateAccount', 'newName', newName)
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new account
         * @param {string} budgetId 
         * @param {string} name 
         * @param {number} amount 
         * @param {number} day day as seen by user in his/her timezone, format : 2 january 2021 &#x3D;&gt; 20210102
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAccount(budgetId: string, name: string, amount: number, day: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccount(budgetId, name, amount, day, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountId id of the account you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Finds accounts by budget
         * @param {string} budgetId id of the budget whose accounts you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAccountsByBudget(budgetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAccountsByBudget(budgetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Rename an account
         * @param {string} accountId 
         * @param {string} newName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(accountId: string, newName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(accountId, newName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new account
         * @param {string} budgetId 
         * @param {string} name 
         * @param {number} amount 
         * @param {number} day day as seen by user in his/her timezone, format : 2 january 2021 &#x3D;&gt; 20210102
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccount(budgetId: string, name: string, amount: number, day: number, options?: any): AxiosPromise<string> {
            return localVarFp.addAccount(budgetId, name, amount, day, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountId id of the account you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accountId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finds accounts by budget
         * @param {string} budgetId id of the budget whose accounts you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountsByBudget(budgetId: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.findAccountsByBudget(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rename an account
         * @param {string} accountId 
         * @param {string} newName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accountId: string, newName: string, options?: any): AxiosPromise<string> {
            return localVarFp.updateAccount(accountId, newName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Add a new account
     * @param {string} budgetId 
     * @param {string} name 
     * @param {number} amount 
     * @param {number} day day as seen by user in his/her timezone, format : 2 january 2021 &#x3D;&gt; 20210102
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public addAccount(budgetId: string, name: string, amount: number, day: number, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).addAccount(budgetId, name, amount, day, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete account
     * @param {string} accountId id of the account you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteAccount(accountId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).deleteAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finds accounts by budget
     * @param {string} budgetId id of the budget whose accounts you want to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public findAccountsByBudget(budgetId: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).findAccountsByBudget(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rename an account
     * @param {string} accountId 
     * @param {string} newName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateAccount(accountId: string, newName: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).updateAccount(accountId, newName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AllocationApi - axios parameter creator
 * @export
 */
export const AllocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new allocation or update an existing one
         * @param {number} month day of the operation (march 2010 &#x3D;&gt; 201003)
         * @param {string} categoryId 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllocation: async (month: number, categoryId: string, amount: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'month' is not null or undefined
            assertParamExists('addAllocation', 'month', month)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('addAllocation', 'categoryId', categoryId)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('addAllocation', 'amount', amount)
            const localVarPath = `/allocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllocationApi - functional programming interface
 * @export
 */
export const AllocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AllocationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new allocation or update an existing one
         * @param {number} month day of the operation (march 2010 &#x3D;&gt; 201003)
         * @param {string} categoryId 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAllocation(month: number, categoryId: string, amount: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Allocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAllocation(month, categoryId, amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AllocationApi - factory interface
 * @export
 */
export const AllocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AllocationApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new allocation or update an existing one
         * @param {number} month day of the operation (march 2010 &#x3D;&gt; 201003)
         * @param {string} categoryId 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllocation(month: number, categoryId: string, amount: number, options?: any): AxiosPromise<Allocation> {
            return localVarFp.addAllocation(month, categoryId, amount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AllocationApi - object-oriented interface
 * @export
 * @class AllocationApi
 * @extends {BaseAPI}
 */
export class AllocationApi extends BaseAPI {
    /**
     * 
     * @summary Add a new allocation or update an existing one
     * @param {number} month day of the operation (march 2010 &#x3D;&gt; 201003)
     * @param {string} categoryId 
     * @param {number} amount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllocationApi
     */
    public addAllocation(month: number, categoryId: string, amount: number, options?: AxiosRequestConfig) {
        return AllocationApiFp(this.configuration).addAllocation(month, categoryId, amount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BudgetApi - axios parameter creator
 * @export
 */
export const BudgetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new budget
         * @param {string} name name of the new budget
         * @param {string} profile type of the new profile (user or company)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBudget: async (name: string, profile: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addBudget', 'name', name)
            // verify required parameter 'profile' is not null or undefined
            assertParamExists('addBudget', 'profile', profile)
            const localVarPath = `/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required

            // authentication refreshTokenId required

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete budget
         * @param {number} budgetId id of the budget you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget: async (budgetId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('deleteBudget', 'budgetId', budgetId)
            const localVarPath = `/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds budgets by user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBudgetsByUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/budget/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a budget
         * @param {string} budgetId id of the updated budget
         * @param {string} newName new name of the new budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget: async (budgetId: string, newName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('updateBudget', 'budgetId', budgetId)
            // verify required parameter 'newName' is not null or undefined
            assertParamExists('updateBudget', 'newName', newName)
            const localVarPath = `/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetApi - functional programming interface
 * @export
 */
export const BudgetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new budget
         * @param {string} name name of the new budget
         * @param {string} profile type of the new profile (user or company)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBudget(name: string, profile: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBudget(name, profile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete budget
         * @param {number} budgetId id of the budget you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBudget(budgetId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBudget(budgetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Finds budgets by user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findBudgetsByUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Budget>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findBudgetsByUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a budget
         * @param {string} budgetId id of the updated budget
         * @param {string} newName new name of the new budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBudget(budgetId: string, newName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBudget(budgetId, newName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BudgetApi - factory interface
 * @export
 */
export const BudgetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new budget
         * @param {string} name name of the new budget
         * @param {string} profile type of the new profile (user or company)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBudget(name: string, profile: string, options?: any): AxiosPromise<string> {
            return localVarFp.addBudget(name, profile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete budget
         * @param {number} budgetId id of the budget you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget(budgetId: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteBudget(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finds budgets by user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBudgetsByUser(options?: any): AxiosPromise<Array<Budget>> {
            return localVarFp.findBudgetsByUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a budget
         * @param {string} budgetId id of the updated budget
         * @param {string} newName new name of the new budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget(budgetId: string, newName: string, options?: any): AxiosPromise<string> {
            return localVarFp.updateBudget(budgetId, newName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BudgetApi - object-oriented interface
 * @export
 * @class BudgetApi
 * @extends {BaseAPI}
 */
export class BudgetApi extends BaseAPI {
    /**
     * 
     * @summary Add a new budget
     * @param {string} name name of the new budget
     * @param {string} profile type of the new profile (user or company)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public addBudget(name: string, profile: string, options?: AxiosRequestConfig) {
        return BudgetApiFp(this.configuration).addBudget(name, profile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete budget
     * @param {number} budgetId id of the budget you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public deleteBudget(budgetId: number, options?: AxiosRequestConfig) {
        return BudgetApiFp(this.configuration).deleteBudget(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finds budgets by user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public findBudgetsByUser(options?: AxiosRequestConfig) {
        return BudgetApiFp(this.configuration).findBudgetsByUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a budget
     * @param {string} budgetId id of the updated budget
     * @param {string} newName new name of the new budget
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public updateBudget(budgetId: string, newName: string, options?: AxiosRequestConfig) {
        return BudgetApiFp(this.configuration).updateBudget(budgetId, newName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BudgetDataApi - axios parameter creator
 * @export
 */
export const BudgetDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find data by budget
         * @param {string} budgetId 
         * @param {number} [startMonth] example : mars 2020 &#x3D; 202003
         * @param {number} [endMonth] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBudgetData: async (budgetId: string, startMonth?: number, endMonth?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('findBudgetData', 'budgetId', budgetId)
            const localVarPath = `/budget/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }

            if (startMonth !== undefined) {
                localVarQueryParameter['start_month'] = startMonth;
            }

            if (endMonth !== undefined) {
                localVarQueryParameter['end_month'] = endMonth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find amount on accounts by budget
         * @param {string} budgetId 
         * @param {number} [month] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTotalBudgetAmount: async (budgetId: string, month?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('findTotalBudgetAmount', 'budgetId', budgetId)
            const localVarPath = `/budget/amount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetDataApi - functional programming interface
 * @export
 */
export const BudgetDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Find data by budget
         * @param {string} budgetId 
         * @param {number} [startMonth] example : mars 2020 &#x3D; 202003
         * @param {number} [endMonth] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findBudgetData(budgetId: string, startMonth?: number, endMonth?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: CategoryData; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findBudgetData(budgetId, startMonth, endMonth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find amount on accounts by budget
         * @param {string} budgetId 
         * @param {number} [month] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTotalBudgetAmount(budgetId: string, month?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTotalBudgetAmount(budgetId, month, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BudgetDataApi - factory interface
 * @export
 */
export const BudgetDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetDataApiFp(configuration)
    return {
        /**
         * 
         * @summary Find data by budget
         * @param {string} budgetId 
         * @param {number} [startMonth] example : mars 2020 &#x3D; 202003
         * @param {number} [endMonth] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBudgetData(budgetId: string, startMonth?: number, endMonth?: number, options?: any): AxiosPromise<{ [key: string]: { [key: string]: CategoryData; }; }> {
            return localVarFp.findBudgetData(budgetId, startMonth, endMonth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find amount on accounts by budget
         * @param {string} budgetId 
         * @param {number} [month] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTotalBudgetAmount(budgetId: string, month?: number, options?: any): AxiosPromise<number> {
            return localVarFp.findTotalBudgetAmount(budgetId, month, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BudgetDataApi - object-oriented interface
 * @export
 * @class BudgetDataApi
 * @extends {BaseAPI}
 */
export class BudgetDataApi extends BaseAPI {
    /**
     * 
     * @summary Find data by budget
     * @param {string} budgetId 
     * @param {number} [startMonth] example : mars 2020 &#x3D; 202003
     * @param {number} [endMonth] example : mars 2020 &#x3D; 202003
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetDataApi
     */
    public findBudgetData(budgetId: string, startMonth?: number, endMonth?: number, options?: AxiosRequestConfig) {
        return BudgetDataApiFp(this.configuration).findBudgetData(budgetId, startMonth, endMonth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find amount on accounts by budget
     * @param {string} budgetId 
     * @param {number} [month] example : mars 2020 &#x3D; 202003
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetDataApi
     */
    public findTotalBudgetAmount(budgetId: string, month?: number, options?: AxiosRequestConfig) {
        return BudgetDataApiFp(this.configuration).findTotalBudgetAmount(budgetId, month, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new category
         * @param {string} name 
         * @param {string} masterCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory: async (name: string, masterCategoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addCategory', 'name', name)
            // verify required parameter 'masterCategoryId' is not null or undefined
            assertParamExists('addCategory', 'masterCategoryId', masterCategoryId)
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (masterCategoryId !== undefined) {
                localVarQueryParameter['master_category_id'] = masterCategoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesByBudget: async (budgetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getCategoriesByBudget', 'budgetId', budgetId)
            const localVarPath = `/category/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {number} [newMasterCategoryId] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (id: string, newName?: string, newMasterCategoryId?: number, newArchived?: boolean, newDeleted?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategory', 'id', id)
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }

            if (newMasterCategoryId !== undefined) {
                localVarQueryParameter['new_master_category_id'] = newMasterCategoryId;
            }

            if (newArchived !== undefined) {
                localVarQueryParameter['new_archived'] = newArchived;
            }

            if (newDeleted !== undefined) {
                localVarQueryParameter['new_deleted'] = newDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new category
         * @param {string} name 
         * @param {string} masterCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCategory(name: string, masterCategoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCategory(name, masterCategoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoriesByBudget(budgetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoriesByBudget(budgetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {number} [newMasterCategoryId] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(id: string, newName?: string, newMasterCategoryId?: number, newArchived?: boolean, newDeleted?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(id, newName, newMasterCategoryId, newArchived, newDeleted, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new category
         * @param {string} name 
         * @param {string} masterCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory(name: string, masterCategoryId: string, options?: any): AxiosPromise<string> {
            return localVarFp.addCategory(name, masterCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesByBudget(budgetId: string, options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getCategoriesByBudget(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {number} [newMasterCategoryId] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: string, newName?: string, newMasterCategoryId?: number, newArchived?: boolean, newDeleted?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.updateCategory(id, newName, newMasterCategoryId, newArchived, newDeleted, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @summary Add a new category
     * @param {string} name 
     * @param {string} masterCategoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public addCategory(name: string, masterCategoryId: string, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration).addCategory(name, masterCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get categories by budget
     * @param {string} budgetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getCategoriesByBudget(budgetId: string, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration).getCategoriesByBudget(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a category
     * @param {string} id 
     * @param {string} [newName] 
     * @param {number} [newMasterCategoryId] 
     * @param {boolean} [newArchived] 
     * @param {boolean} [newDeleted] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public updateCategory(id: string, newName?: string, newMasterCategoryId?: number, newArchived?: boolean, newDeleted?: boolean, options?: AxiosRequestConfig) {
        return CategoryApiFp(this.configuration).updateCategory(id, newName, newMasterCategoryId, newArchived, newDeleted, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MasterCategoryApi - axios parameter creator
 * @export
 */
export const MasterCategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new master category
         * @param {string} name 
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMasterCategory: async (name: string, budgetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addMasterCategory', 'name', name)
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('addMasterCategory', 'budgetId', budgetId)
            const localVarPath = `/mcategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get master categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterCategoriesByBudget: async (budgetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getMasterCategoriesByBudget', 'budgetId', budgetId)
            const localVarPath = `/mcategory/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update master category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMasterCategory: async (id: string, newName?: string, newArchived?: boolean, newDeleted?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMasterCategory', 'id', id)
            const localVarPath = `/mcategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }

            if (newArchived !== undefined) {
                localVarQueryParameter['new_archived'] = newArchived;
            }

            if (newDeleted !== undefined) {
                localVarQueryParameter['new_deleted'] = newDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MasterCategoryApi - functional programming interface
 * @export
 */
export const MasterCategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MasterCategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new master category
         * @param {string} name 
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMasterCategory(name: string, budgetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMasterCategory(name, budgetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get master categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterCategoriesByBudget(budgetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMasterCategoriesByBudget(budgetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update master category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMasterCategory(id: string, newName?: string, newArchived?: boolean, newDeleted?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMasterCategory(id, newName, newArchived, newDeleted, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MasterCategoryApi - factory interface
 * @export
 */
export const MasterCategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MasterCategoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new master category
         * @param {string} name 
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMasterCategory(name: string, budgetId: string, options?: any): AxiosPromise<string> {
            return localVarFp.addMasterCategory(name, budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get master categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterCategoriesByBudget(budgetId: string, options?: any): AxiosPromise<Array<MasterCategory>> {
            return localVarFp.getMasterCategoriesByBudget(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update master category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMasterCategory(id: string, newName?: string, newArchived?: boolean, newDeleted?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.updateMasterCategory(id, newName, newArchived, newDeleted, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MasterCategoryApi - object-oriented interface
 * @export
 * @class MasterCategoryApi
 * @extends {BaseAPI}
 */
export class MasterCategoryApi extends BaseAPI {
    /**
     * 
     * @summary Add a new master category
     * @param {string} name 
     * @param {string} budgetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MasterCategoryApi
     */
    public addMasterCategory(name: string, budgetId: string, options?: AxiosRequestConfig) {
        return MasterCategoryApiFp(this.configuration).addMasterCategory(name, budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get master categories by budget
     * @param {string} budgetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MasterCategoryApi
     */
    public getMasterCategoriesByBudget(budgetId: string, options?: AxiosRequestConfig) {
        return MasterCategoryApiFp(this.configuration).getMasterCategoriesByBudget(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update master category
     * @param {string} id 
     * @param {string} [newName] 
     * @param {boolean} [newArchived] 
     * @param {boolean} [newDeleted] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MasterCategoryApi
     */
    public updateMasterCategory(id: string, newName?: string, newArchived?: boolean, newDeleted?: boolean, options?: AxiosRequestConfig) {
        return MasterCategoryApiFp(this.configuration).updateMasterCategory(id, newName, newArchived, newDeleted, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OperationApi - axios parameter creator
 * @export
 */
export const OperationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new operation
         * @param {string} accountId 
         * @param {number} [day] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [categoryId] 
         * @param {number} [amount] 
         * @param {string} [memo] 
         * @param {boolean} [pending] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOperation: async (accountId: string, day?: number, categoryId?: string, amount?: number, memo?: string, pending?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addOperation', 'accountId', accountId)
            const localVarPath = `/operation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (memo !== undefined) {
                localVarQueryParameter['memo'] = memo;
            }

            if (pending !== undefined) {
                localVarQueryParameter['pending'] = pending;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete operation
         * @param {string} operationId id of the operation you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperation: async (operationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('deleteOperation', 'operationId', operationId)
            const localVarPath = `/operation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (operationId !== undefined) {
                localVarQueryParameter['operation_id'] = operationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find operation by account
         * @param {string} accountId id of the account whose operations you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOperationsByAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('findOperationsByAccount', 'accountId', accountId)
            const localVarPath = `/operation/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find operation by budget
         * @param {string} budgetId id of the budget whose operations you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOperationsByBudget: async (budgetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('findOperationsByBudget', 'budgetId', budgetId)
            const localVarPath = `/operation/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add operations from ofx file
         * @param {string} accountId id of the account where operations must be created
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importOfxFile: async (accountId: string, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('importOfxFile', 'accountId', accountId)
            const localVarPath = `/operation/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/ofx';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an operation
         * @param {string} operationId 
         * @param {string} [newAccountId] 
         * @param {number} [newDay] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [newCategoryId] 
         * @param {number} [newAmount] 
         * @param {string} [newMemo] 
         * @param {boolean} [newPending] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperation: async (operationId: string, newAccountId?: string, newDay?: number, newCategoryId?: string, newAmount?: number, newMemo?: string, newPending?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('updateOperation', 'operationId', operationId)
            const localVarPath = `/operation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (operationId !== undefined) {
                localVarQueryParameter['operation_id'] = operationId;
            }

            if (newAccountId !== undefined) {
                localVarQueryParameter['new_account_id'] = newAccountId;
            }

            if (newDay !== undefined) {
                localVarQueryParameter['new_day'] = newDay;
            }

            if (newCategoryId !== undefined) {
                localVarQueryParameter['new_category_id'] = newCategoryId;
            }

            if (newAmount !== undefined) {
                localVarQueryParameter['new_amount'] = newAmount;
            }

            if (newMemo !== undefined) {
                localVarQueryParameter['new_memo'] = newMemo;
            }

            if (newPending !== undefined) {
                localVarQueryParameter['new_pending'] = newPending;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationApi - functional programming interface
 * @export
 */
export const OperationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new operation
         * @param {string} accountId 
         * @param {number} [day] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [categoryId] 
         * @param {number} [amount] 
         * @param {string} [memo] 
         * @param {boolean} [pending] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOperation(accountId: string, day?: number, categoryId?: string, amount?: number, memo?: string, pending?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOperation(accountId, day, categoryId, amount, memo, pending, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete operation
         * @param {string} operationId id of the operation you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOperation(operationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOperation(operationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find operation by account
         * @param {string} accountId id of the account whose operations you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOperationsByAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Operation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOperationsByAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find operation by budget
         * @param {string} budgetId id of the budget whose operations you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOperationsByBudget(budgetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Operation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOperationsByBudget(budgetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add operations from ofx file
         * @param {string} accountId id of the account where operations must be created
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importOfxFile(accountId: string, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importOfxFile(accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an operation
         * @param {string} operationId 
         * @param {string} [newAccountId] 
         * @param {number} [newDay] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [newCategoryId] 
         * @param {number} [newAmount] 
         * @param {string} [newMemo] 
         * @param {boolean} [newPending] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOperation(operationId: string, newAccountId?: string, newDay?: number, newCategoryId?: string, newAmount?: number, newMemo?: string, newPending?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOperation(operationId, newAccountId, newDay, newCategoryId, newAmount, newMemo, newPending, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OperationApi - factory interface
 * @export
 */
export const OperationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperationApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new operation
         * @param {string} accountId 
         * @param {number} [day] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [categoryId] 
         * @param {number} [amount] 
         * @param {string} [memo] 
         * @param {boolean} [pending] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOperation(accountId: string, day?: number, categoryId?: string, amount?: number, memo?: string, pending?: boolean, options?: any): AxiosPromise<Operation> {
            return localVarFp.addOperation(accountId, day, categoryId, amount, memo, pending, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete operation
         * @param {string} operationId id of the operation you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperation(operationId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteOperation(operationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find operation by account
         * @param {string} accountId id of the account whose operations you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOperationsByAccount(accountId: string, options?: any): AxiosPromise<Array<Operation>> {
            return localVarFp.findOperationsByAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find operation by budget
         * @param {string} budgetId id of the budget whose operations you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOperationsByBudget(budgetId: string, options?: any): AxiosPromise<Array<Operation>> {
            return localVarFp.findOperationsByBudget(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add operations from ofx file
         * @param {string} accountId id of the account where operations must be created
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importOfxFile(accountId: string, body?: string, options?: any): AxiosPromise<string> {
            return localVarFp.importOfxFile(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an operation
         * @param {string} operationId 
         * @param {string} [newAccountId] 
         * @param {number} [newDay] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [newCategoryId] 
         * @param {number} [newAmount] 
         * @param {string} [newMemo] 
         * @param {boolean} [newPending] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperation(operationId: string, newAccountId?: string, newDay?: number, newCategoryId?: string, newAmount?: number, newMemo?: string, newPending?: boolean, options?: any): AxiosPromise<Operation> {
            return localVarFp.updateOperation(operationId, newAccountId, newDay, newCategoryId, newAmount, newMemo, newPending, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationApi - object-oriented interface
 * @export
 * @class OperationApi
 * @extends {BaseAPI}
 */
export class OperationApi extends BaseAPI {
    /**
     * 
     * @summary Add a new operation
     * @param {string} accountId 
     * @param {number} [day] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
     * @param {string} [categoryId] 
     * @param {number} [amount] 
     * @param {string} [memo] 
     * @param {boolean} [pending] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public addOperation(accountId: string, day?: number, categoryId?: string, amount?: number, memo?: string, pending?: boolean, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).addOperation(accountId, day, categoryId, amount, memo, pending, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete operation
     * @param {string} operationId id of the operation you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public deleteOperation(operationId: string, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).deleteOperation(operationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find operation by account
     * @param {string} accountId id of the account whose operations you want to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public findOperationsByAccount(accountId: string, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).findOperationsByAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find operation by budget
     * @param {string} budgetId id of the budget whose operations you want to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public findOperationsByBudget(budgetId: string, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).findOperationsByBudget(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add operations from ofx file
     * @param {string} accountId id of the account where operations must be created
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public importOfxFile(accountId: string, body?: string, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).importOfxFile(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an operation
     * @param {string} operationId 
     * @param {string} [newAccountId] 
     * @param {number} [newDay] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
     * @param {string} [newCategoryId] 
     * @param {number} [newAmount] 
     * @param {string} [newMemo] 
     * @param {boolean} [newPending] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public updateOperation(operationId: string, newAccountId?: string, newDay?: number, newCategoryId?: string, newAmount?: number, newMemo?: string, newPending?: boolean, options?: AxiosRequestConfig) {
        return OperationApiFp(this.configuration).updateOperation(operationId, newAccountId, newDay, newCategoryId, newAmount, newMemo, newPending, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonApi - axios parameter creator
 * @export
 */
export const PersonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get billing portal URL, new subscription if not subscribed, billing management if already subscribed
         * @param {string} _package chosen package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBillingPortalSession: async (_package: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_package' is not null or undefined
            assertParamExists('createBillingPortalSession', '_package', _package)
            const localVarPath = `/billing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required

            // authentication refreshTokenId required

            if (_package !== undefined) {
                localVarQueryParameter['package'] = _package;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a person
         * @param {string} name 
         * @param {string} password 
         * @param {string} email 
         * @param {string} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson: async (name: string, password: string, email: string, profile: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createPerson', 'name', name)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('createPerson', 'password', password)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('createPerson', 'email', email)
            // verify required parameter 'profile' is not null or undefined
            assertParamExists('createPerson', 'profile', profile)
            const localVarPath = `/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (email: string, password: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('createSession', 'email', email)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('createSession', 'password', password)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required

            // authentication refreshTokenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the person metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required

            // authentication refreshTokenId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the person metadata
         * @param {string} [newName] 
         * @param {string} [newStyle] 
         * @param {boolean} [newDyslexia] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson: async (newName?: string, newStyle?: string, newDyslexia?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication accessToken required

            // authentication refreshTokenId required

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }

            if (newStyle !== undefined) {
                localVarQueryParameter['new_style'] = newStyle;
            }

            if (newDyslexia !== undefined) {
                localVarQueryParameter['new_dyslexia'] = newDyslexia;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonApi - functional programming interface
 * @export
 */
export const PersonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary get billing portal URL, new subscription if not subscribed, billing management if already subscribed
         * @param {string} _package chosen package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBillingPortalSession(_package: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBillingPortalSession(_package, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a person
         * @param {string} name 
         * @param {string} password 
         * @param {string} email 
         * @param {string} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPerson(name: string, password: string, email: string, profile: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPerson(name, password, email, profile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(email: string, password: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(email, password, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSession(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the person metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerson(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPerson(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the person metadata
         * @param {string} [newName] 
         * @param {string} [newStyle] 
         * @param {boolean} [newDyslexia] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePerson(newName?: string, newStyle?: string, newDyslexia?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePerson(newName, newStyle, newDyslexia, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonApi - factory interface
 * @export
 */
export const PersonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonApiFp(configuration)
    return {
        /**
         * 
         * @summary get billing portal URL, new subscription if not subscribed, billing management if already subscribed
         * @param {string} _package chosen package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBillingPortalSession(_package: string, options?: any): AxiosPromise<string> {
            return localVarFp.createBillingPortalSession(_package, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a person
         * @param {string} name 
         * @param {string} password 
         * @param {string} email 
         * @param {string} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson(name: string, password: string, email: string, profile: string, options?: any): AxiosPromise<string> {
            return localVarFp.createPerson(name, password, email, profile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(email: string, password: string, options?: any): AxiosPromise<string> {
            return localVarFp.createSession(email, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(options?: any): AxiosPromise<string> {
            return localVarFp.deleteSession(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the person metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(options?: any): AxiosPromise<Array<Person>> {
            return localVarFp.getPerson(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the person metadata
         * @param {string} [newName] 
         * @param {string} [newStyle] 
         * @param {boolean} [newDyslexia] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(newName?: string, newStyle?: string, newDyslexia?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.updatePerson(newName, newStyle, newDyslexia, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonApi - object-oriented interface
 * @export
 * @class PersonApi
 * @extends {BaseAPI}
 */
export class PersonApi extends BaseAPI {
    /**
     * 
     * @summary get billing portal URL, new subscription if not subscribed, billing management if already subscribed
     * @param {string} _package chosen package
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public createBillingPortalSession(_package: string, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).createBillingPortalSession(_package, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a person
     * @param {string} name 
     * @param {string} password 
     * @param {string} email 
     * @param {string} profile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public createPerson(name: string, password: string, email: string, profile: string, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).createPerson(name, password, email, profile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {string} email 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public createSession(email: string, password: string, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).createSession(email, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public deleteSession(options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).deleteSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the person metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPerson(options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPerson(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the person metadata
     * @param {string} [newName] 
     * @param {string} [newStyle] 
     * @param {boolean} [newDyslexia] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public updatePerson(newName?: string, newStyle?: string, newDyslexia?: boolean, options?: AxiosRequestConfig) {
        return PersonApiFp(this.configuration).updatePerson(newName, newStyle, newDyslexia, options).then((request) => request(this.axios, this.basePath));
    }
}


