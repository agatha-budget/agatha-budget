/* tslint:disable */
/* eslint-disable */
/**
 * Agatha
 * Agatha api webfront to back
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import { globalAxios } from "@/services/api/httpservice";
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'bankAccountId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'syncedUntil'?: number;
}
/**
 * 
 * @export
 * @interface Allocation
 */
export interface Allocation {
    /**
     * 
     * @type {number}
     * @memberof Allocation
     */
    'month': number;
    /**
     * 
     * @type {string}
     * @memberof Allocation
     */
    'categoryId': string;
    /**
     * 
     * @type {number}
     * @memberof Allocation
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface Bank
 */
export interface Bank {
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Bank
     */
    'logo': string;
}
/**
 * 
 * @export
 * @interface BankAccount
 */
export interface BankAccount {
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccount
     */
    'bankId': string;
    /**
     * Id used by the bank for this account VS id which is its id in our own db
     * @type {string}
     * @memberof BankAccount
     */
    'bankingId'?: string;
    /**
     * 
     * @type {number}
     * @memberof BankAccount
     */
    'timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof BankAccount
     */
    'balance'?: number;
}
/**
 * 
 * @export
 * @interface Budget
 */
export interface Budget {
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Budget
     */
    'profile': string;
    /**
     * 
     * @type {boolean}
     * @memberof Budget
     */
    'isDefault'?: boolean;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'masterCategoryId': string;
    /**
     * 
     * @type {boolean}
     * @memberof Category
     */
    'archived': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Category
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface CategoryData
 */
export interface CategoryData {
    /**
     * 
     * @type {number}
     * @memberof CategoryData
     */
    'allocated': number;
    /**
     * 
     * @type {number}
     * @memberof CategoryData
     */
    'spent': number;
    /**
     * 
     * @type {number}
     * @memberof CategoryData
     */
    'available': number;
}
/**
 * 
 * @export
 * @interface MasterCategory
 */
export interface MasterCategory {
    /**
     * 
     * @type {string}
     * @memberof MasterCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MasterCategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MasterCategory
     */
    'budgetId': string;
    /**
     * 
     * @type {boolean}
     * @memberof MasterCategory
     */
    'deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof MasterCategory
     */
    'color': string;
}
/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Operation
     */
    'day': number;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    'categoryId': string;
    /**
     * 
     * @type {number}
     * @memberof Operation
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    'memo': string;
    /**
     * 
     * @type {boolean}
     * @memberof Operation
     */
    'pending': boolean;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    'motherOperationId': string;
}
/**
 * 
 * @export
 * @interface OperationWithDaughters
 */
export interface OperationWithDaughters {
    /**
     * 
     * @type {string}
     * @memberof OperationWithDaughters
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof OperationWithDaughters
     */
    'day': number;
    /**
     * 
     * @type {string}
     * @memberof OperationWithDaughters
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof OperationWithDaughters
     */
    'categoryId': string;
    /**
     * 
     * @type {number}
     * @memberof OperationWithDaughters
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof OperationWithDaughters
     */
    'memo': string;
    /**
     * 
     * @type {boolean}
     * @memberof OperationWithDaughters
     */
    'pending': boolean;
    /**
     * 
     * @type {Array<Operation>}
     * @memberof OperationWithDaughters
     */
    'daughters': Array<Operation>;
}
/**
 * 
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof Person
     */
    'billingStatus': boolean;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'style': string;
    /**
     * 
     * @type {boolean}
     * @memberof Person
     */
    'dyslexia': boolean;
    /**
     * 
     * @type {number}
     * @memberof Person
     */
    'creationDate': number;
    /**
     * 
     * @type {boolean}
     * @memberof Person
     */
    'hasBillingId': boolean;
}
/**
 * 
 * @export
 * @interface PostIt
 */
export interface PostIt {
    /**
     * 
     * @type {number}
     * @memberof PostIt
     */
    'month': number;
    /**
     * 
     * @type {string}
     * @memberof PostIt
     */
    'budgetId': string;
    /**
     * 
     * @type {string}
     * @memberof PostIt
     */
    'text': string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new account
         * @param {string} budgetId 
         * @param {string} name 
         * @param {number} amount 
         * @param {number} day day as seen by user in his/her timezone, format : 2 january 2021 &#x3D;&gt; 20210102
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccount: async (budgetId: string, name: string, amount: number, day: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('addAccount', 'budgetId', budgetId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addAccount', 'name', name)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('addAccount', 'amount', amount)
            // verify required parameter 'day' is not null or undefined
            assertParamExists('addAccount', 'day', day)
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountId id of the account you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId)
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds accounts by budget
         * @param {string} budgetId id of the budget whose accounts you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountsByBudget: async (budgetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('findAccountsByBudget', 'budgetId', budgetId)
            const localVarPath = `/account/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rename an account
         * @param {string} accountId 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (accountId: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccount', 'accountId', accountId)
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary edit bank association
         * @param {string} accountId 
         * @param {boolean} importHistory 
         * @param {string} [bankAccountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountBankAssociation: async (accountId: string, importHistory: boolean, bankAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccountBankAssociation', 'accountId', accountId)
            // verify required parameter 'importHistory' is not null or undefined
            assertParamExists('updateAccountBankAssociation', 'importHistory', importHistory)
            const localVarPath = `/account/bank`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (bankAccountId !== undefined) {
                localVarQueryParameter['bank_account_id'] = bankAccountId;
            }

            if (importHistory !== undefined) {
                localVarQueryParameter['import_history'] = importHistory;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new account
         * @param {string} budgetId 
         * @param {string} name 
         * @param {number} amount 
         * @param {number} day day as seen by user in his/her timezone, format : 2 january 2021 &#x3D;&gt; 20210102
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAccount(budgetId: string, name: string, amount: number, day: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccount(budgetId, name, amount, day, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.addAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountId id of the account you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.deleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Finds accounts by budget
         * @param {string} budgetId id of the budget whose accounts you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAccountsByBudget(budgetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAccountsByBudget(budgetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.findAccountsByBudget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Rename an account
         * @param {string} accountId 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(accountId: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(accountId, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.updateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary edit bank association
         * @param {string} accountId 
         * @param {boolean} importHistory 
         * @param {string} [bankAccountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountBankAssociation(accountId: string, importHistory: boolean, bankAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountBankAssociation(accountId, importHistory, bankAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.updateAccountBankAssociation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new account
         * @param {string} budgetId 
         * @param {string} name 
         * @param {number} amount 
         * @param {number} day day as seen by user in his/her timezone, format : 2 january 2021 &#x3D;&gt; 20210102
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccount(budgetId: string, name: string, amount: number, day: number, options?: any): AxiosPromise<string> {
            return localVarFp.addAccount(budgetId, name, amount, day, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete account
         * @param {string} accountId id of the account you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accountId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finds accounts by budget
         * @param {string} budgetId id of the budget whose accounts you want to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountsByBudget(budgetId: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.findAccountsByBudget(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rename an account
         * @param {string} accountId 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accountId: string, name?: string, options?: any): AxiosPromise<string> {
            return localVarFp.updateAccount(accountId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary edit bank association
         * @param {string} accountId 
         * @param {boolean} importHistory 
         * @param {string} [bankAccountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountBankAssociation(accountId: string, importHistory: boolean, bankAccountId?: string, options?: any): AxiosPromise<string> {
            return localVarFp.updateAccountBankAssociation(accountId, importHistory, bankAccountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Add a new account
     * @param {string} budgetId 
     * @param {string} name 
     * @param {number} amount 
     * @param {number} day day as seen by user in his/her timezone, format : 2 january 2021 &#x3D;&gt; 20210102
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public addAccount(budgetId: string, name: string, amount: number, day: number, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).addAccount(budgetId, name, amount, day, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete account
     * @param {string} accountId id of the account you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).deleteAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finds accounts by budget
     * @param {string} budgetId id of the budget whose accounts you want to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public findAccountsByBudget(budgetId: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).findAccountsByBudget(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rename an account
     * @param {string} accountId 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateAccount(accountId: string, name?: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).updateAccount(accountId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary edit bank association
     * @param {string} accountId 
     * @param {boolean} importHistory 
     * @param {string} [bankAccountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateAccountBankAssociation(accountId: string, importHistory: boolean, bankAccountId?: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).updateAccountBankAssociation(accountId, importHistory, bankAccountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AllocationApi - axios parameter creator
 * @export
 */
export const AllocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new allocation or update an existing one
         * @param {number} month day of the operation (march 2010 &#x3D;&gt; 201003)
         * @param {string} categoryId 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllocation: async (month: number, categoryId: string, amount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'month' is not null or undefined
            assertParamExists('addAllocation', 'month', month)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('addAllocation', 'categoryId', categoryId)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('addAllocation', 'amount', amount)
            const localVarPath = `/allocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllocationApi - functional programming interface
 * @export
 */
export const AllocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AllocationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new allocation or update an existing one
         * @param {number} month day of the operation (march 2010 &#x3D;&gt; 201003)
         * @param {string} categoryId 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAllocation(month: number, categoryId: string, amount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Allocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAllocation(month, categoryId, amount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllocationApi.addAllocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AllocationApi - factory interface
 * @export
 */
export const AllocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AllocationApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new allocation or update an existing one
         * @param {number} month day of the operation (march 2010 &#x3D;&gt; 201003)
         * @param {string} categoryId 
         * @param {number} amount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllocation(month: number, categoryId: string, amount: number, options?: any): AxiosPromise<Allocation> {
            return localVarFp.addAllocation(month, categoryId, amount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AllocationApi - object-oriented interface
 * @export
 * @class AllocationApi
 * @extends {BaseAPI}
 */
export class AllocationApi extends BaseAPI {
    /**
     * 
     * @summary Add a new allocation or update an existing one
     * @param {number} month day of the operation (march 2010 &#x3D;&gt; 201003)
     * @param {string} categoryId 
     * @param {number} amount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllocationApi
     */
    public addAllocation(month: number, categoryId: string, amount: number, options?: RawAxiosRequestConfig) {
        return AllocationApiFp(this.configuration).addAllocation(month, categoryId, amount, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankingApi - axios parameter creator
 * @export
 */
export const BankingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get authorized accounts list
         * @param {string} budgetId budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizedAccounts: async (budgetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getAuthorizedAccounts', 'budgetId', budgetId)
            const localVarPath = `/bank/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            if (budgetId !== undefined) {
                localVarQueryParameter['budgetId'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get availables banks list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBanks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getBankOperations
         * @param {string} [accountId] to synchronise a specific account
         * @param {string} [budgetId] to synchronise all accounts from a budget (ignored if accountId is set)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankOperations: async (accountId?: string, budgetId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bank/operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (budgetId !== undefined) {
                localVarQueryParameter['budgetId'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get bank agreement portal URL
         * @param {string} bankId identifier of the wanted bank
         * @param {string} budgetId id of the current budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkForBankAgreement: async (bankId: string, budgetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankId' is not null or undefined
            assertParamExists('getLinkForBankAgreement', 'bankId', bankId)
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getLinkForBankAgreement', 'budgetId', budgetId)
            const localVarPath = `/banking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            if (bankId !== undefined) {
                localVarQueryParameter['bankId'] = bankId;
            }

            if (budgetId !== undefined) {
                localVarQueryParameter['budgetId'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary synchronize with banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bank/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateBankingInfo
         * @param {string} bankAgreementId identifier of the wanted bank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBankAccountList: async (bankAgreementId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankAgreementId' is not null or undefined
            assertParamExists('updateBankAccountList', 'bankAgreementId', bankAgreementId)
            const localVarPath = `/banking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            if (bankAgreementId !== undefined) {
                localVarQueryParameter['bankAgreementId'] = bankAgreementId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankingApi - functional programming interface
 * @export
 */
export const BankingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary get authorized accounts list
         * @param {string} budgetId budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorizedAccounts(budgetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankAccount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthorizedAccounts(budgetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankingApi.getAuthorizedAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get availables banks list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableBanks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bank>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableBanks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankingApi.getAvailableBanks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary getBankOperations
         * @param {string} [accountId] to synchronise a specific account
         * @param {string} [budgetId] to synchronise all accounts from a budget (ignored if accountId is set)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBankOperations(accountId?: string, budgetId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBankOperations(accountId, budgetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankingApi.getBankOperations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get bank agreement portal URL
         * @param {string} bankId identifier of the wanted bank
         * @param {string} budgetId id of the current budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkForBankAgreement(bankId: string, budgetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkForBankAgreement(bankId, budgetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankingApi.getLinkForBankAgreement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary synchronize with banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankingApi.syncAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary updateBankingInfo
         * @param {string} bankAgreementId identifier of the wanted bank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBankAccountList(bankAgreementId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBankAccountList(bankAgreementId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankingApi.updateBankAccountList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankingApi - factory interface
 * @export
 */
export const BankingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankingApiFp(configuration)
    return {
        /**
         * 
         * @summary get authorized accounts list
         * @param {string} budgetId budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizedAccounts(budgetId: string, options?: any): AxiosPromise<Array<BankAccount>> {
            return localVarFp.getAuthorizedAccounts(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get availables banks list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBanks(options?: any): AxiosPromise<Array<Bank>> {
            return localVarFp.getAvailableBanks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getBankOperations
         * @param {string} [accountId] to synchronise a specific account
         * @param {string} [budgetId] to synchronise all accounts from a budget (ignored if accountId is set)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankOperations(accountId?: string, budgetId?: string, options?: any): AxiosPromise<string> {
            return localVarFp.getBankOperations(accountId, budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get bank agreement portal URL
         * @param {string} bankId identifier of the wanted bank
         * @param {string} budgetId id of the current budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkForBankAgreement(bankId: string, budgetId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getLinkForBankAgreement(bankId, budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary synchronize with banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAll(options?: any): AxiosPromise<string> {
            return localVarFp.syncAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateBankingInfo
         * @param {string} bankAgreementId identifier of the wanted bank
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBankAccountList(bankAgreementId: string, options?: any): AxiosPromise<string> {
            return localVarFp.updateBankAccountList(bankAgreementId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankingApi - object-oriented interface
 * @export
 * @class BankingApi
 * @extends {BaseAPI}
 */
export class BankingApi extends BaseAPI {
    /**
     * 
     * @summary get authorized accounts list
     * @param {string} budgetId budget
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingApi
     */
    public getAuthorizedAccounts(budgetId: string, options?: RawAxiosRequestConfig) {
        return BankingApiFp(this.configuration).getAuthorizedAccounts(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get availables banks list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingApi
     */
    public getAvailableBanks(options?: RawAxiosRequestConfig) {
        return BankingApiFp(this.configuration).getAvailableBanks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getBankOperations
     * @param {string} [accountId] to synchronise a specific account
     * @param {string} [budgetId] to synchronise all accounts from a budget (ignored if accountId is set)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingApi
     */
    public getBankOperations(accountId?: string, budgetId?: string, options?: RawAxiosRequestConfig) {
        return BankingApiFp(this.configuration).getBankOperations(accountId, budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get bank agreement portal URL
     * @param {string} bankId identifier of the wanted bank
     * @param {string} budgetId id of the current budget
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingApi
     */
    public getLinkForBankAgreement(bankId: string, budgetId: string, options?: RawAxiosRequestConfig) {
        return BankingApiFp(this.configuration).getLinkForBankAgreement(bankId, budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary synchronize with banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingApi
     */
    public syncAll(options?: RawAxiosRequestConfig) {
        return BankingApiFp(this.configuration).syncAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateBankingInfo
     * @param {string} bankAgreementId identifier of the wanted bank
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingApi
     */
    public updateBankAccountList(bankAgreementId: string, options?: RawAxiosRequestConfig) {
        return BankingApiFp(this.configuration).updateBankAccountList(bankAgreementId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BudgetApi - axios parameter creator
 * @export
 */
export const BudgetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new budget
         * @param {string} name name of the new budget
         * @param {string} profile type of the new profile (user or company)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBudget: async (name: string, profile: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addBudget', 'name', name)
            // verify required parameter 'profile' is not null or undefined
            assertParamExists('addBudget', 'profile', profile)
            const localVarPath = `/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete budget
         * @param {number} budgetId id of the budget you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget: async (budgetId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('deleteBudget', 'budgetId', budgetId)
            const localVarPath = `/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds budgets by user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBudgetsByUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/budget/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a budget
         * @param {string} budgetId id of the updated budget
         * @param {string} newName new name of the new budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget: async (budgetId: string, newName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('updateBudget', 'budgetId', budgetId)
            // verify required parameter 'newName' is not null or undefined
            assertParamExists('updateBudget', 'newName', newName)
            const localVarPath = `/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetApi - functional programming interface
 * @export
 */
export const BudgetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new budget
         * @param {string} name name of the new budget
         * @param {string} profile type of the new profile (user or company)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBudget(name: string, profile: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBudget(name, profile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.addBudget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete budget
         * @param {number} budgetId id of the budget you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBudget(budgetId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBudget(budgetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.deleteBudget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Finds budgets by user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findBudgetsByUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Budget>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findBudgetsByUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.findBudgetsByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a budget
         * @param {string} budgetId id of the updated budget
         * @param {string} newName new name of the new budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBudget(budgetId: string, newName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBudget(budgetId, newName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetApi.updateBudget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BudgetApi - factory interface
 * @export
 */
export const BudgetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new budget
         * @param {string} name name of the new budget
         * @param {string} profile type of the new profile (user or company)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBudget(name: string, profile: string, options?: any): AxiosPromise<string> {
            return localVarFp.addBudget(name, profile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete budget
         * @param {number} budgetId id of the budget you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBudget(budgetId: number, options?: any): AxiosPromise<string> {
            return localVarFp.deleteBudget(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finds budgets by user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBudgetsByUser(options?: any): AxiosPromise<Array<Budget>> {
            return localVarFp.findBudgetsByUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a budget
         * @param {string} budgetId id of the updated budget
         * @param {string} newName new name of the new budget
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBudget(budgetId: string, newName: string, options?: any): AxiosPromise<string> {
            return localVarFp.updateBudget(budgetId, newName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BudgetApi - object-oriented interface
 * @export
 * @class BudgetApi
 * @extends {BaseAPI}
 */
export class BudgetApi extends BaseAPI {
    /**
     * 
     * @summary Add a new budget
     * @param {string} name name of the new budget
     * @param {string} profile type of the new profile (user or company)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public addBudget(name: string, profile: string, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).addBudget(name, profile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete budget
     * @param {number} budgetId id of the budget you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public deleteBudget(budgetId: number, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).deleteBudget(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finds budgets by user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public findBudgetsByUser(options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).findBudgetsByUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a budget
     * @param {string} budgetId id of the updated budget
     * @param {string} newName new name of the new budget
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetApi
     */
    public updateBudget(budgetId: string, newName: string, options?: RawAxiosRequestConfig) {
        return BudgetApiFp(this.configuration).updateBudget(budgetId, newName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BudgetDataApi - axios parameter creator
 * @export
 */
export const BudgetDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find data by budget
         * @param {string} budgetId 
         * @param {number} [startMonth] example : mars 2020 &#x3D; 202003
         * @param {number} [endMonth] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBudgetData: async (budgetId: string, startMonth?: number, endMonth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('findBudgetData', 'budgetId', budgetId)
            const localVarPath = `/budget/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }

            if (startMonth !== undefined) {
                localVarQueryParameter['start_month'] = startMonth;
            }

            if (endMonth !== undefined) {
                localVarQueryParameter['end_month'] = endMonth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find amount on accounts by budget
         * @param {string} budgetId 
         * @param {number} [month] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTotalBudgetAmount: async (budgetId: string, month?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('findTotalBudgetAmount', 'budgetId', budgetId)
            const localVarPath = `/budget/amount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetDataApi - functional programming interface
 * @export
 */
export const BudgetDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BudgetDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Find data by budget
         * @param {string} budgetId 
         * @param {number} [startMonth] example : mars 2020 &#x3D; 202003
         * @param {number} [endMonth] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findBudgetData(budgetId: string, startMonth?: number, endMonth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: CategoryData; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findBudgetData(budgetId, startMonth, endMonth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetDataApi.findBudgetData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Find amount on accounts by budget
         * @param {string} budgetId 
         * @param {number} [month] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTotalBudgetAmount(budgetId: string, month?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTotalBudgetAmount(budgetId, month, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BudgetDataApi.findTotalBudgetAmount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BudgetDataApi - factory interface
 * @export
 */
export const BudgetDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BudgetDataApiFp(configuration)
    return {
        /**
         * 
         * @summary Find data by budget
         * @param {string} budgetId 
         * @param {number} [startMonth] example : mars 2020 &#x3D; 202003
         * @param {number} [endMonth] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBudgetData(budgetId: string, startMonth?: number, endMonth?: number, options?: any): AxiosPromise<{ [key: string]: { [key: string]: CategoryData; }; }> {
            return localVarFp.findBudgetData(budgetId, startMonth, endMonth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find amount on accounts by budget
         * @param {string} budgetId 
         * @param {number} [month] example : mars 2020 &#x3D; 202003
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTotalBudgetAmount(budgetId: string, month?: number, options?: any): AxiosPromise<number> {
            return localVarFp.findTotalBudgetAmount(budgetId, month, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BudgetDataApi - object-oriented interface
 * @export
 * @class BudgetDataApi
 * @extends {BaseAPI}
 */
export class BudgetDataApi extends BaseAPI {
    /**
     * 
     * @summary Find data by budget
     * @param {string} budgetId 
     * @param {number} [startMonth] example : mars 2020 &#x3D; 202003
     * @param {number} [endMonth] example : mars 2020 &#x3D; 202003
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetDataApi
     */
    public findBudgetData(budgetId: string, startMonth?: number, endMonth?: number, options?: RawAxiosRequestConfig) {
        return BudgetDataApiFp(this.configuration).findBudgetData(budgetId, startMonth, endMonth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find amount on accounts by budget
     * @param {string} budgetId 
     * @param {number} [month] example : mars 2020 &#x3D; 202003
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BudgetDataApi
     */
    public findTotalBudgetAmount(budgetId: string, month?: number, options?: RawAxiosRequestConfig) {
        return BudgetDataApiFp(this.configuration).findTotalBudgetAmount(budgetId, month, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new category
         * @param {string} name 
         * @param {string} masterCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory: async (name: string, masterCategoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addCategory', 'name', name)
            // verify required parameter 'masterCategoryId' is not null or undefined
            assertParamExists('addCategory', 'masterCategoryId', masterCategoryId)
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (masterCategoryId !== undefined) {
                localVarQueryParameter['master_category_id'] = masterCategoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesByBudget: async (budgetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getCategoriesByBudget', 'budgetId', budgetId)
            const localVarPath = `/category/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {string} [newMasterCategoryId] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (id: string, newName?: string, newMasterCategoryId?: string, newArchived?: boolean, newDeleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategory', 'id', id)
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }

            if (newMasterCategoryId !== undefined) {
                localVarQueryParameter['new_master_category_id'] = newMasterCategoryId;
            }

            if (newArchived !== undefined) {
                localVarQueryParameter['new_archived'] = newArchived;
            }

            if (newDeleted !== undefined) {
                localVarQueryParameter['new_deleted'] = newDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new category
         * @param {string} name 
         * @param {string} masterCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCategory(name: string, masterCategoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCategory(name, masterCategoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.addCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoriesByBudget(budgetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoriesByBudget(budgetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.getCategoriesByBudget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {string} [newMasterCategoryId] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(id: string, newName?: string, newMasterCategoryId?: string, newArchived?: boolean, newDeleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(id, newName, newMasterCategoryId, newArchived, newDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryApi.updateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new category
         * @param {string} name 
         * @param {string} masterCategoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory(name: string, masterCategoryId: string, options?: any): AxiosPromise<string> {
            return localVarFp.addCategory(name, masterCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesByBudget(budgetId: string, options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getCategoriesByBudget(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {string} [newMasterCategoryId] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: string, newName?: string, newMasterCategoryId?: string, newArchived?: boolean, newDeleted?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.updateCategory(id, newName, newMasterCategoryId, newArchived, newDeleted, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @summary Add a new category
     * @param {string} name 
     * @param {string} masterCategoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public addCategory(name: string, masterCategoryId: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).addCategory(name, masterCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get categories by budget
     * @param {string} budgetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getCategoriesByBudget(budgetId: string, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).getCategoriesByBudget(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a category
     * @param {string} id 
     * @param {string} [newName] 
     * @param {string} [newMasterCategoryId] 
     * @param {boolean} [newArchived] 
     * @param {boolean} [newDeleted] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public updateCategory(id: string, newName?: string, newMasterCategoryId?: string, newArchived?: boolean, newDeleted?: boolean, options?: RawAxiosRequestConfig) {
        return CategoryApiFp(this.configuration).updateCategory(id, newName, newMasterCategoryId, newArchived, newDeleted, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EasterEggsApi - axios parameter creator
 * @export
 */
export const EasterEggsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Say No
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _false: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Say Hello
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Say Keycloak
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keycloak: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keycloak`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Say Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EasterEggsApi - functional programming interface
 * @export
 */
export const EasterEggsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EasterEggsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Say No
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _false(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._false(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EasterEggsApi._false']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Say Hello
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EasterEggsApi.hello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Say Keycloak
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keycloak(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keycloak(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EasterEggsApi.keycloak']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Say Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EasterEggsApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EasterEggsApi - factory interface
 * @export
 */
export const EasterEggsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EasterEggsApiFp(configuration)
    return {
        /**
         * 
         * @summary Say No
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _false(options?: any): AxiosPromise<string> {
            return localVarFp._false(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Say Hello
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hello(options?: any): AxiosPromise<string> {
            return localVarFp.hello(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Say Keycloak
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keycloak(options?: any): AxiosPromise<string> {
            return localVarFp.keycloak(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Say Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EasterEggsApi - object-oriented interface
 * @export
 * @class EasterEggsApi
 * @extends {BaseAPI}
 */
export class EasterEggsApi extends BaseAPI {
    /**
     * 
     * @summary Say No
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasterEggsApi
     */
    public _false(options?: RawAxiosRequestConfig) {
        return EasterEggsApiFp(this.configuration)._false(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Say Hello
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasterEggsApi
     */
    public hello(options?: RawAxiosRequestConfig) {
        return EasterEggsApiFp(this.configuration).hello(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Say Keycloak
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasterEggsApi
     */
    public keycloak(options?: RawAxiosRequestConfig) {
        return EasterEggsApiFp(this.configuration).keycloak(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Say Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EasterEggsApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return EasterEggsApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MasterCategoryApi - axios parameter creator
 * @export
 */
export const MasterCategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new master category
         * @param {string} name 
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMasterCategory: async (name: string, budgetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addMasterCategory', 'name', name)
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('addMasterCategory', 'budgetId', budgetId)
            const localVarPath = `/mcategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get master categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterCategoriesByBudget: async (budgetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getMasterCategoriesByBudget', 'budgetId', budgetId)
            const localVarPath = `/mcategory/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update master category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {string} [newColor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMasterCategory: async (id: string, newName?: string, newArchived?: boolean, newDeleted?: boolean, newColor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMasterCategory', 'id', id)
            const localVarPath = `/mcategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }

            if (newArchived !== undefined) {
                localVarQueryParameter['new_archived'] = newArchived;
            }

            if (newDeleted !== undefined) {
                localVarQueryParameter['new_deleted'] = newDeleted;
            }

            if (newColor !== undefined) {
                localVarQueryParameter['new_color'] = newColor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MasterCategoryApi - functional programming interface
 * @export
 */
export const MasterCategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MasterCategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new master category
         * @param {string} name 
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMasterCategory(name: string, budgetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMasterCategory(name, budgetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MasterCategoryApi.addMasterCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get master categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterCategoriesByBudget(budgetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMasterCategoriesByBudget(budgetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MasterCategoryApi.getMasterCategoriesByBudget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update master category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {string} [newColor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMasterCategory(id: string, newName?: string, newArchived?: boolean, newDeleted?: boolean, newColor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMasterCategory(id, newName, newArchived, newDeleted, newColor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MasterCategoryApi.updateMasterCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MasterCategoryApi - factory interface
 * @export
 */
export const MasterCategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MasterCategoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new master category
         * @param {string} name 
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMasterCategory(name: string, budgetId: string, options?: any): AxiosPromise<string> {
            return localVarFp.addMasterCategory(name, budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get master categories by budget
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterCategoriesByBudget(budgetId: string, options?: any): AxiosPromise<Array<MasterCategory>> {
            return localVarFp.getMasterCategoriesByBudget(budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update master category
         * @param {string} id 
         * @param {string} [newName] 
         * @param {boolean} [newArchived] 
         * @param {boolean} [newDeleted] 
         * @param {string} [newColor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMasterCategory(id: string, newName?: string, newArchived?: boolean, newDeleted?: boolean, newColor?: string, options?: any): AxiosPromise<string> {
            return localVarFp.updateMasterCategory(id, newName, newArchived, newDeleted, newColor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MasterCategoryApi - object-oriented interface
 * @export
 * @class MasterCategoryApi
 * @extends {BaseAPI}
 */
export class MasterCategoryApi extends BaseAPI {
    /**
     * 
     * @summary Add a new master category
     * @param {string} name 
     * @param {string} budgetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MasterCategoryApi
     */
    public addMasterCategory(name: string, budgetId: string, options?: RawAxiosRequestConfig) {
        return MasterCategoryApiFp(this.configuration).addMasterCategory(name, budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get master categories by budget
     * @param {string} budgetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MasterCategoryApi
     */
    public getMasterCategoriesByBudget(budgetId: string, options?: RawAxiosRequestConfig) {
        return MasterCategoryApiFp(this.configuration).getMasterCategoriesByBudget(budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update master category
     * @param {string} id 
     * @param {string} [newName] 
     * @param {boolean} [newArchived] 
     * @param {boolean} [newDeleted] 
     * @param {string} [newColor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MasterCategoryApi
     */
    public updateMasterCategory(id: string, newName?: string, newArchived?: boolean, newDeleted?: boolean, newColor?: string, options?: RawAxiosRequestConfig) {
        return MasterCategoryApiFp(this.configuration).updateMasterCategory(id, newName, newArchived, newDeleted, newColor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OperationApi - axios parameter creator
 * @export
 */
export const OperationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new operation
         * @param {string} accountId 
         * @param {number} [day] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [categoryId] 
         * @param {number} [amount] 
         * @param {string} [memo] 
         * @param {boolean} [pending] 
         * @param {string} [motherOperationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOperation: async (accountId: string, day?: number, categoryId?: string, amount?: number, memo?: string, pending?: boolean, motherOperationId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('addOperation', 'accountId', accountId)
            const localVarPath = `/operation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (memo !== undefined) {
                localVarQueryParameter['memo'] = memo;
            }

            if (pending !== undefined) {
                localVarQueryParameter['pending'] = pending;
            }

            if (motherOperationId !== undefined) {
                localVarQueryParameter['mother_operation_id'] = motherOperationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete operation
         * @param {string} operationId id of the operation you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperation: async (operationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('deleteOperation', 'operationId', operationId)
            const localVarPath = `/operation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (operationId !== undefined) {
                localVarQueryParameter['operation_id'] = operationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find operation by account and category
         * @param {string} accountId id of the account whose operations you want to retrieve
         * @param {string} [categoryId] if apply filter by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOperationsByAccount: async (accountId: string, categoryId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('findOperationsByAccount', 'accountId', accountId)
            const localVarPath = `/operation/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find operation by budget and category
         * @param {string} budgetId id of the budget whose operations you want to retrieve
         * @param {string} [categoryId] if apply filter by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOperationsByBudget: async (budgetId: string, categoryId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('findOperationsByBudget', 'budgetId', budgetId)
            const localVarPath = `/operation/budget`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add operations from ofx file
         * @param {string} accountId id of the account where operations must be created
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importOfxFile: async (accountId: string, body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('importOfxFile', 'accountId', accountId)
            const localVarPath = `/operation/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/ofx';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an operation
         * @param {string} operationId 
         * @param {string} [newAccountId] 
         * @param {number} [newDay] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [newCategoryId] 
         * @param {boolean} [removeCategory] 
         * @param {number} [newAmount] 
         * @param {string} [newMemo] 
         * @param {boolean} [newPending] 
         * @param {string} [newMotherOperationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperation: async (operationId: string, newAccountId?: string, newDay?: number, newCategoryId?: string, removeCategory?: boolean, newAmount?: number, newMemo?: string, newPending?: boolean, newMotherOperationId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            assertParamExists('updateOperation', 'operationId', operationId)
            const localVarPath = `/operation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (operationId !== undefined) {
                localVarQueryParameter['operation_id'] = operationId;
            }

            if (newAccountId !== undefined) {
                localVarQueryParameter['new_account_id'] = newAccountId;
            }

            if (newDay !== undefined) {
                localVarQueryParameter['new_day'] = newDay;
            }

            if (newCategoryId !== undefined) {
                localVarQueryParameter['new_category_id'] = newCategoryId;
            }

            if (removeCategory !== undefined) {
                localVarQueryParameter['remove_category'] = removeCategory;
            }

            if (newAmount !== undefined) {
                localVarQueryParameter['new_amount'] = newAmount;
            }

            if (newMemo !== undefined) {
                localVarQueryParameter['new_memo'] = newMemo;
            }

            if (newPending !== undefined) {
                localVarQueryParameter['new_pending'] = newPending;
            }

            if (newMotherOperationId !== undefined) {
                localVarQueryParameter['new_mother-operation_id'] = newMotherOperationId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationApi - functional programming interface
 * @export
 */
export const OperationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new operation
         * @param {string} accountId 
         * @param {number} [day] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [categoryId] 
         * @param {number} [amount] 
         * @param {string} [memo] 
         * @param {boolean} [pending] 
         * @param {string} [motherOperationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOperation(accountId: string, day?: number, categoryId?: string, amount?: number, memo?: string, pending?: boolean, motherOperationId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOperation(accountId, day, categoryId, amount, memo, pending, motherOperationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationApi.addOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete operation
         * @param {string} operationId id of the operation you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOperation(operationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOperation(operationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationApi.deleteOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Find operation by account and category
         * @param {string} accountId id of the account whose operations you want to retrieve
         * @param {string} [categoryId] if apply filter by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOperationsByAccount(accountId: string, categoryId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OperationWithDaughters>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOperationsByAccount(accountId, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationApi.findOperationsByAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Find operation by budget and category
         * @param {string} budgetId id of the budget whose operations you want to retrieve
         * @param {string} [categoryId] if apply filter by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOperationsByBudget(budgetId: string, categoryId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OperationWithDaughters>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOperationsByBudget(budgetId, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationApi.findOperationsByBudget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add operations from ofx file
         * @param {string} accountId id of the account where operations must be created
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importOfxFile(accountId: string, body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importOfxFile(accountId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationApi.importOfxFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an operation
         * @param {string} operationId 
         * @param {string} [newAccountId] 
         * @param {number} [newDay] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [newCategoryId] 
         * @param {boolean} [removeCategory] 
         * @param {number} [newAmount] 
         * @param {string} [newMemo] 
         * @param {boolean} [newPending] 
         * @param {string} [newMotherOperationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOperation(operationId: string, newAccountId?: string, newDay?: number, newCategoryId?: string, removeCategory?: boolean, newAmount?: number, newMemo?: string, newPending?: boolean, newMotherOperationId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOperation(operationId, newAccountId, newDay, newCategoryId, removeCategory, newAmount, newMemo, newPending, newMotherOperationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationApi.updateOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OperationApi - factory interface
 * @export
 */
export const OperationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperationApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new operation
         * @param {string} accountId 
         * @param {number} [day] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [categoryId] 
         * @param {number} [amount] 
         * @param {string} [memo] 
         * @param {boolean} [pending] 
         * @param {string} [motherOperationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOperation(accountId: string, day?: number, categoryId?: string, amount?: number, memo?: string, pending?: boolean, motherOperationId?: string, options?: any): AxiosPromise<Operation> {
            return localVarFp.addOperation(accountId, day, categoryId, amount, memo, pending, motherOperationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete operation
         * @param {string} operationId id of the operation you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperation(operationId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteOperation(operationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find operation by account and category
         * @param {string} accountId id of the account whose operations you want to retrieve
         * @param {string} [categoryId] if apply filter by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOperationsByAccount(accountId: string, categoryId?: string, options?: any): AxiosPromise<Array<OperationWithDaughters>> {
            return localVarFp.findOperationsByAccount(accountId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find operation by budget and category
         * @param {string} budgetId id of the budget whose operations you want to retrieve
         * @param {string} [categoryId] if apply filter by category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOperationsByBudget(budgetId: string, categoryId?: string, options?: any): AxiosPromise<Array<OperationWithDaughters>> {
            return localVarFp.findOperationsByBudget(budgetId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add operations from ofx file
         * @param {string} accountId id of the account where operations must be created
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importOfxFile(accountId: string, body?: string, options?: any): AxiosPromise<string> {
            return localVarFp.importOfxFile(accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an operation
         * @param {string} operationId 
         * @param {string} [newAccountId] 
         * @param {number} [newDay] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
         * @param {string} [newCategoryId] 
         * @param {boolean} [removeCategory] 
         * @param {number} [newAmount] 
         * @param {string} [newMemo] 
         * @param {boolean} [newPending] 
         * @param {string} [newMotherOperationId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOperation(operationId: string, newAccountId?: string, newDay?: number, newCategoryId?: string, removeCategory?: boolean, newAmount?: number, newMemo?: string, newPending?: boolean, newMotherOperationId?: string, options?: any): AxiosPromise<Operation> {
            return localVarFp.updateOperation(operationId, newAccountId, newDay, newCategoryId, removeCategory, newAmount, newMemo, newPending, newMotherOperationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationApi - object-oriented interface
 * @export
 * @class OperationApi
 * @extends {BaseAPI}
 */
export class OperationApi extends BaseAPI {
    /**
     * 
     * @summary Add a new operation
     * @param {string} accountId 
     * @param {number} [day] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
     * @param {string} [categoryId] 
     * @param {number} [amount] 
     * @param {string} [memo] 
     * @param {boolean} [pending] 
     * @param {string} [motherOperationId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public addOperation(accountId: string, day?: number, categoryId?: string, amount?: number, memo?: string, pending?: boolean, motherOperationId?: string, options?: RawAxiosRequestConfig) {
        return OperationApiFp(this.configuration).addOperation(accountId, day, categoryId, amount, memo, pending, motherOperationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete operation
     * @param {string} operationId id of the operation you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public deleteOperation(operationId: string, options?: RawAxiosRequestConfig) {
        return OperationApiFp(this.configuration).deleteOperation(operationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find operation by account and category
     * @param {string} accountId id of the account whose operations you want to retrieve
     * @param {string} [categoryId] if apply filter by category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public findOperationsByAccount(accountId: string, categoryId?: string, options?: RawAxiosRequestConfig) {
        return OperationApiFp(this.configuration).findOperationsByAccount(accountId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find operation by budget and category
     * @param {string} budgetId id of the budget whose operations you want to retrieve
     * @param {string} [categoryId] if apply filter by category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public findOperationsByBudget(budgetId: string, categoryId?: string, options?: RawAxiosRequestConfig) {
        return OperationApiFp(this.configuration).findOperationsByBudget(budgetId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add operations from ofx file
     * @param {string} accountId id of the account where operations must be created
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public importOfxFile(accountId: string, body?: string, options?: RawAxiosRequestConfig) {
        return OperationApiFp(this.configuration).importOfxFile(accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an operation
     * @param {string} operationId 
     * @param {string} [newAccountId] 
     * @param {number} [newDay] day of the operation (2 march 2010 &#x3D;&gt; 20100302)
     * @param {string} [newCategoryId] 
     * @param {boolean} [removeCategory] 
     * @param {number} [newAmount] 
     * @param {string} [newMemo] 
     * @param {boolean} [newPending] 
     * @param {string} [newMotherOperationId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationApi
     */
    public updateOperation(operationId: string, newAccountId?: string, newDay?: number, newCategoryId?: string, removeCategory?: boolean, newAmount?: number, newMemo?: string, newPending?: boolean, newMotherOperationId?: string, options?: RawAxiosRequestConfig) {
        return OperationApiFp(this.configuration).updateOperation(operationId, newAccountId, newDay, newCategoryId, removeCategory, newAmount, newMemo, newPending, newMotherOperationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonApi - axios parameter creator
 * @export
 */
export const PersonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get billing portal URL, new subscription if not subscribed, billing management if already subscribed
         * @param {string} [_package] chosen package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBillingPortalSession: async (_package?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            if (_package !== undefined) {
                localVarQueryParameter['package'] = _package;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a person
         * @param {string} name 
         * @param {string} password 
         * @param {string} email 
         * @param {string} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson: async (name: string, password: string, email: string, profile: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createPerson', 'name', name)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('createPerson', 'password', password)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('createPerson', 'email', email)
            // verify required parameter 'profile' is not null or undefined
            assertParamExists('createPerson', 'profile', profile)
            const localVarPath = `/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (email: string, password: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('createSession', 'email', email)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('createSession', 'password', password)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the person metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the person metadata
         * @param {string} [newName] 
         * @param {string} [newStyle] 
         * @param {boolean} [newDyslexia] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson: async (newName?: string, newStyle?: string, newDyslexia?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }

            if (newStyle !== undefined) {
                localVarQueryParameter['new_style'] = newStyle;
            }

            if (newDyslexia !== undefined) {
                localVarQueryParameter['new_dyslexia'] = newDyslexia;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonApi - functional programming interface
 * @export
 */
export const PersonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary get billing portal URL, new subscription if not subscribed, billing management if already subscribed
         * @param {string} [_package] chosen package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBillingPortalSession(_package?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBillingPortalSession(_package, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonApi.createBillingPortalSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a person
         * @param {string} name 
         * @param {string} password 
         * @param {string} email 
         * @param {string} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPerson(name: string, password: string, email: string, profile: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPerson(name, password, email, profile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonApi.createPerson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(email: string, password: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(email, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonApi.createSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSession(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonApi.deleteSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the person metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerson(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPerson(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonApi.getPerson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the person metadata
         * @param {string} [newName] 
         * @param {string} [newStyle] 
         * @param {boolean} [newDyslexia] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePerson(newName?: string, newStyle?: string, newDyslexia?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePerson(newName, newStyle, newDyslexia, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonApi.updatePerson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonApi - factory interface
 * @export
 */
export const PersonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonApiFp(configuration)
    return {
        /**
         * 
         * @summary get billing portal URL, new subscription if not subscribed, billing management if already subscribed
         * @param {string} [_package] chosen package
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBillingPortalSession(_package?: string, options?: any): AxiosPromise<string> {
            return localVarFp.createBillingPortalSession(_package, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a person
         * @param {string} name 
         * @param {string} password 
         * @param {string} email 
         * @param {string} profile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson(name: string, password: string, email: string, profile: string, options?: any): AxiosPromise<string> {
            return localVarFp.createPerson(name, password, email, profile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {string} email 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(email: string, password: string, options?: any): AxiosPromise<string> {
            return localVarFp.createSession(email, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(options?: any): AxiosPromise<string> {
            return localVarFp.deleteSession(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the person metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(options?: any): AxiosPromise<Array<Person>> {
            return localVarFp.getPerson(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the person metadata
         * @param {string} [newName] 
         * @param {string} [newStyle] 
         * @param {boolean} [newDyslexia] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(newName?: string, newStyle?: string, newDyslexia?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.updatePerson(newName, newStyle, newDyslexia, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonApi - object-oriented interface
 * @export
 * @class PersonApi
 * @extends {BaseAPI}
 */
export class PersonApi extends BaseAPI {
    /**
     * 
     * @summary get billing portal URL, new subscription if not subscribed, billing management if already subscribed
     * @param {string} [_package] chosen package
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public createBillingPortalSession(_package?: string, options?: RawAxiosRequestConfig) {
        return PersonApiFp(this.configuration).createBillingPortalSession(_package, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a person
     * @param {string} name 
     * @param {string} password 
     * @param {string} email 
     * @param {string} profile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public createPerson(name: string, password: string, email: string, profile: string, options?: RawAxiosRequestConfig) {
        return PersonApiFp(this.configuration).createPerson(name, password, email, profile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {string} email 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public createSession(email: string, password: string, options?: RawAxiosRequestConfig) {
        return PersonApiFp(this.configuration).createSession(email, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public deleteSession(options?: RawAxiosRequestConfig) {
        return PersonApiFp(this.configuration).deleteSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the person metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public getPerson(options?: RawAxiosRequestConfig) {
        return PersonApiFp(this.configuration).getPerson(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the person metadata
     * @param {string} [newName] 
     * @param {string} [newStyle] 
     * @param {boolean} [newDyslexia] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonApi
     */
    public updatePerson(newName?: string, newStyle?: string, newDyslexia?: boolean, options?: RawAxiosRequestConfig) {
        return PersonApiFp(this.configuration).updatePerson(newName, newStyle, newDyslexia, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PostItApi - axios parameter creator
 * @export
 */
export const PostItApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get post-it by month and budget
         * @param {number} month month of the post-it (march 2022 &#x3D;&gt; 202203)
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostIt: async (month: number, budgetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getPostIt', 'month', month)
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('getPostIt', 'budgetId', budgetId)
            const localVarPath = `/postIt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new post-it or update an existing one
         * @param {number} month month of the post-it (march 2022 &#x3D;&gt; 202203)
         * @param {string} budgetId 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostIt: async (month: number, budgetId: string, text: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'month' is not null or undefined
            assertParamExists('updatePostIt', 'month', month)
            // verify required parameter 'budgetId' is not null or undefined
            assertParamExists('updatePostIt', 'budgetId', budgetId)
            // verify required parameter 'text' is not null or undefined
            assertParamExists('updatePostIt', 'text', text)
            const localVarPath = `/postIt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (budgetId !== undefined) {
                localVarQueryParameter['budget_id'] = budgetId;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostItApi - functional programming interface
 * @export
 */
export const PostItApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostItApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get post-it by month and budget
         * @param {number} month month of the post-it (march 2022 &#x3D;&gt; 202203)
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostIt(month: number, budgetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PostIt>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPostIt(month, budgetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostItApi.getPostIt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a new post-it or update an existing one
         * @param {number} month month of the post-it (march 2022 &#x3D;&gt; 202203)
         * @param {string} budgetId 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePostIt(month: number, budgetId: string, text: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePostIt(month, budgetId, text, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostItApi.updatePostIt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PostItApi - factory interface
 * @export
 */
export const PostItApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostItApiFp(configuration)
    return {
        /**
         * 
         * @summary Get post-it by month and budget
         * @param {number} month month of the post-it (march 2022 &#x3D;&gt; 202203)
         * @param {string} budgetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostIt(month: number, budgetId: string, options?: any): AxiosPromise<Array<PostIt>> {
            return localVarFp.getPostIt(month, budgetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new post-it or update an existing one
         * @param {number} month month of the post-it (march 2022 &#x3D;&gt; 202203)
         * @param {string} budgetId 
         * @param {string} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePostIt(month: number, budgetId: string, text: string, options?: any): AxiosPromise<string> {
            return localVarFp.updatePostIt(month, budgetId, text, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostItApi - object-oriented interface
 * @export
 * @class PostItApi
 * @extends {BaseAPI}
 */
export class PostItApi extends BaseAPI {
    /**
     * 
     * @summary Get post-it by month and budget
     * @param {number} month month of the post-it (march 2022 &#x3D;&gt; 202203)
     * @param {string} budgetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostItApi
     */
    public getPostIt(month: number, budgetId: string, options?: RawAxiosRequestConfig) {
        return PostItApiFp(this.configuration).getPostIt(month, budgetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new post-it or update an existing one
     * @param {number} month month of the post-it (march 2022 &#x3D;&gt; 202203)
     * @param {string} budgetId 
     * @param {string} text 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostItApi
     */
    public updatePostIt(month: number, budgetId: string, text: string, options?: RawAxiosRequestConfig) {
        return PostItApiFp(this.configuration).updatePostIt(month, budgetId, text, options).then((request) => request(this.axios, this.basePath));
    }
}



